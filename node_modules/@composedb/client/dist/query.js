export function toIndexQuery(source) {
    const { after , before , first , last , ...base } = source;
    let query;
    if (first != null) {
        query = {
            ...base,
            first
        };
        if (after != null) {
            // eslint-disable-next-line
            // @ts-ignore defined as read-only
            query.after = after;
        }
        return query;
    }
    if (last != null) {
        query = {
            ...base,
            last
        };
        if (before != null) {
            // eslint-disable-next-line
            // @ts-ignore defined as read-only
            query.before = before;
        }
        return query;
    }
    throw new Error('Missing "first" or "last" connection argument');
}
export function toRelayConnection(ceramic, page) {
    return {
        edges: page.edges.map(({ cursor , node  })=>{
            return {
                cursor,
                node: ceramic.buildStreamFromState(node)
            };
        }),
        pageInfo: {
            ...page.pageInfo,
            startCursor: page.pageInfo.startCursor ?? null,
            endCursor: page.pageInfo.endCursor ?? null
        }
    };
}
export async function queryConnection(ceramic, query) {
    const page = await ceramic.index.queryIndex(toIndexQuery(query));
    return toRelayConnection(ceramic, page);
}
export async function querySingle(ceramic, query) {
    const result = await ceramic.index.queryIndex({
        ...query,
        last: 1
    });
    const edge = result.edges[0];
    return edge ? ceramic.buildStreamFromState(edge.node) : null;
}
